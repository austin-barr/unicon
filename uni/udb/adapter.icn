link ximage
link strings
link findre
import json
global seq, lastUdbCmd, waitingForTerminal, requestQueue, cmdQueue

class Adapter(
   port,
   sock,
   dapcomSock,
   filePath,
   shellProcessId,
   clientDetails,
   currentRequestBody,
   udbError,
   tpArgs,
   bpSuccess,
   numBreakpoints,
   breakpointList,
   numScopes,
   scopesList
   )

   # Process a result from udb in table or list form.
   method processResult(res)
   local response
      write("udb -> udap:\n"|| ximage(res))
      \res | fail

      if type(res) == "table" then
         process_udb_output_table(res)
      else if type(res) == "list" then
         every resTable := !res do
            if type(resTable) == "table" then
               process_udb_output_table(res)
   end

   # Get the next command in cmdQueue.
   method getNextCommand()
      local request_body, request_seq, request_command, request_arguments, cmdElement, cmd, cmd_request

      repeat {
         if *cmdQueue ~= 0 then {
            cmdElement := pop(cmdQueue)
            currentRequestBody := cmdElement["request"]
            cmd := cmdElement["command"]
            write("udb command: "||cmd||"\n")
            return cmd
         }
         every request_body := get_request(sock) do {
            write("command: "||jtou(request_body)["command"]||"\n")
            if \waitingForTerminal then {
                  if jtou(request_body)["command"] ~== "runInTerminal" then {
                     write("put "||jtou(request_body)["command"])
                     put(requestQueue, request_body)
                     next
                  }
                  else {
                     waitingForTerminal := &null
                     process_request(request_body)
                     load_cmds()

                     every process_request(pop(requestQueue))
                  }
            }
            else {
               process_request(request_body)
            }
         }
      }
   end

   method put_cmdQueue(cmd, request_body)
   local cmdElement := table()
      cmdElement["command"] := cmd
      cmdElement["request"] := \request_body
      put(cmdQueue, cmdElement)
   end

   method push_cmdQueue(cmd, request_body)
   local cmdElement := table()
      cmdElement["command"] := cmd
      cmdElement["request"] := \request_body
      push(cmdQueue, cmdElement)
   end

   # Put commands necessary for loading target program into cmdQueue.
   method load_cmds()
      local dir, procs, cmd

      filePath ? dir := tab(findre("\/[^\/]+$"))
         put_cmdQueue("dir args " || dir)

      if procs := pathfind("udb") then {
         procs ? procs := tab(findre("unicon") + 6)
         procs ||:= "/ipl/procs"
         put_cmdQueue("dir args " || procs)
      }

      if \tpArgs then
         put_cmdQueue("load " || filePath || " " || tpArgs)
      else
         put_cmdQueue("load " || filePath)

    end

   # Given a DAP client request body, process that request.
   method process_request(request_json)
      local request_body, request_seq, request_command, request_arguments, response_body

      request_body := jtou(request_json)

      request_seq := request_body["seq"]
      request_command := request_body["command"]
      request_arguments := request_body["arguments"]
      response_body := request_body["body"]

      write("client -> udap: " || request_json||"\n")

      case request_command of {
         "initialize": { initialize(request_seq, request_command, request_arguments) }
         "launch" : { launch(request_seq, request_command, request_arguments) }
         "setBreakpoints" : { set_breakpoints(request_body, request_seq, request_command, request_arguments) }
         "configurationDone" : { put_cmdQueue("run", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "threads" : { threads(request_seq, request_command) }
         "continue" : { put_cmdQueue("cont", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "next" : { put_cmdQueue("next", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "stepIn" : { put_cmdQueue("step", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "stepOut" : { put_cmdQueue("return", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "stackTrace" : { put_cmdQueue("bt", request_body)}
         "scopes" : { every put_cmdQueue(!push([: "print -"||!"glsp" :], "frame "||request_arguments["frameId"]), request_body) }
         "variables" : { put_cmdQueue("print -" || "glsp"[request_arguments["variablesReference"]], request_body) }
         "disconnect" : { acknowledge(request_seq, request_command); disconnect() }
         "runInTerminal" : { if member(response_body, "shellProcessId") then shellProcessId := response_body["shellProcessId"] }
         "evaluate" : { evaluate(request_body, request_seq, request_command, request_arguments) }
         default: { write("Don't know what to do with: ", request_command) }
      }
   end

   # Attempt to read messages from client given a socket and returns each message as a generator.
   method get_request(sock)
      local request_body, msg, len

      while /request_body | request_body == "" do {

         select(sock)

         msg := ready(sock)

         # Handling socket reading anomoly: header alone or header + request_body
         while msg ~== "" do {
            msg ? {
               tab(find("Content-Length:") + 16)
               len := integer(tab(many(&digits)))
               tab(upto("\r\n\r\n") + 4)
               if pos(0) then {
                  request_body := ready(sock, len)
               }
               else {
                  request_body := move(len)
                  msg := tab(0)
               }
            }
            suspend request_body
         }
      }
   end

   # Create and return a response for client in json format.
   method build_response(request_seq, success, request_command, body, message)
      local responseTable, responseBody, responseHeader

      responseTable := [
         "seq": seq;
         "type": "response";
         "request_seq": request_seq;
         "success": success;
         "command": request_command
      ]
      responseTable["message"] := \message
      responseTable["body"] := \body

      responseBody := tojson(responseTable)
      responseHeader := "Content-Length:" || *responseBody || "\r\n\r\n"

      write("udap -> client: " || responseBody)

      seq +:= 1

      return responseHeader || responseBody
   end

   # Create and return a request for client in json format.
   method build_request(command, arguments)
      local requestTable, requestBody, requestHeader

      requestTable := [
         "seq": seq;
         "type": "request";
         "command": command
      ]
      requestTable["arguments"] := \arguments

      requestBody := tojson(requestTable)
      requestHeader := "Content-Length:" || *requestBody || "\r\n\r\n"

      write("udap -> client: " || requestBody)

      seq +:= 1

      return requestHeader || requestBody
   end

   # Create and return an event for client in json format.
   method build_event(event, body)
      local eventTable, eventBody, eventHeader

      eventTable := [
         "seq": seq;
         "type": "event";
         "event": event
      ]
      eventTable["body"] := \body

      eventBody := tojson(eventTable)
      eventHeader := "Content-Length:" || *eventBody || "\r\n\r\n"

      write("udap -> client: " || eventBody)

      seq +:= 1

      return eventHeader || eventBody
   end

   # Handles all the things required from a client "initialize" request.
   method initialize(request_seq, request_command, request_arguments)
      local capabilitiesTable, res, udbPort, startRes, event, req

      clientDetails := \request_arguments

      capabilitiesTable := [
         "supportsConfigurationDoneRequest": "__true__";
         "supportsValueFormattingOptions": "__true__"
      ]

      res := build_response(request_seq, "__true__", request_command, capabilitiesTable)
      writes(sock, res)

      event := build_event("initialized")
      writes(sock, event)
   end

   # Handles all the things required from a client "launch" request.
   method launch(request_seq, request_command, request_arguments)
      local res, pth, event, dapPort

      pth := request_arguments["program"]
      pth ? {
         tab(match("^\"\\"))
         pth := tab(find(".icn"))
      }
      filePath := pth

      if member(request_arguments, "args") then {
         tpArgs := request_arguments["args"]
      }

      dapPort := integer(port) + 10

      event := build_request("runInTerminal", [
         "kind": "integrated";
         "cwd": "";
         "title": "udbTerminal";
         "args": ["dapcom " || dapPort];
         "argsCanBeInterpretedByShell": "__true__"])
      writes(sock, event)
      waitingForTerminal := 1

      dapcomSock := open_sock(dapPort)

      if /dapcomSock then {
         res := build_response(request_seq, "__false__", request_command, &null, "udap failed to open dapcomSock: " || dapPort)
         writes(sock, res)
         return
      }

      res := build_response(request_seq, "__true__", request_command)
      writes(sock, res)
   end

   # Handles all the things required from a client "setBreakpoints" request.
   method set_breakpoints(request_body, request_seq, request_command, request_arguments)
      local res, breakpointTable, breakpoint, resTable

      breakpointTable := [
         "breakpoints": request_arguments["breakpoints"]
      ]

      put_cmdQueue("clear break", request_body)
      numBreakpoints +:= 1

      every bp := !request_arguments["breakpoints"] do {
         line := bp["line"]
         cond := bp["condition"]
         put_cmdQueue("b " || request_arguments["source"]["name"] || ":" || line, request_body)
         numBreakpoints +:= 1
      }
   end

   # Handles all the things required from a client "threads" request.
   method threads(request_seq, request_command)
      local res, threadsTable

      threadsTable := [
         "threads": [[
            "id": 1;
            "name": "main"
         ]]
      ]

      res := build_response(request_seq, "__true__", request_command, threadsTable)
      writes(sock, res)
   end

   # Default response for request that only requires an acknowledgement.
   method acknowledge(request_seq, request_command)
      local res

      res := build_response(request_seq, "__true__", request_command)
      writes(sock, res)
   end

   # Given a udb output table as 'outputTable', process that table.
   # EVERYTHING that udb outputs should go through this method.
   method process_udb_output_table(outputTable)
      local udbRes := "", event, curCmd

      curCmd := (\currentRequestBody)["command"] | "none"

      udbRes := outputTable["consoleMsg"]

      /outputTable["type"] := "console"
      if not (outputTable["type"] == ("exited" | "stderr" | "crash")) then {
         event := build_event("output", [
            "category": "console";
            "output": udbRes])
         writes(sock, event)
         if outputTable["type"] == "breakpoint" then {
            event := build_event("stopped", [
               "reason": "breakpoint";
               "description": udbRes;
               "hitBreakpointIds": [outputTable["id"]];
               "threadId": 1])
            writes(sock, event)
         }
         else if outputTable["type"] == "step" then {
            event := build_event("stopped", [
               "reason": "step";
               "threadId": 1])
            writes(sock, event)
         }

         case curCmd of {
            "setBreakpoints": processBreakpointResult(outputTable)
            "stackTrace": processStackTraceResult(outputTable)
            "scopes": processScopesResult(outputTable)
            "variables": processVariablesResult(outputTable)
            "evaluate": processEvaluateResult(outputTable)
         }
      }
      else if outputTable["type"] == "stderr" then {
         event := build_event("output", [
            "category": "stderr";
            "output": udbRes])
         writes(sock, event)
         event := build_event("stopped", [
            "reason": "exception";
            "description": udbRes;
            "text": udbRes;
            "threadId": 1])
         writes(sock, event)
      }
      else if outputTable["type"] == "exited" then {
         event := build_event("exited", [
            "exitCode",
            outputTable["exitCode"]])
         writes(sock, event)
      }
      else if outputTable["type"] == "crash" then {
         handle_error(outputTable)
         return
      }
      if \outputTable["requireResponse"] then {
         event := build_event("output", [
            "category": "console";
            "output": "[answered Y; input not from terminal]\n"])
         writes(sock, event)

         # Maybe we put "Y" at the head of cmdQueue?
         # Returning "Y" from this method won't do anything currently.
         # return "Y"
         push_cmdQueue("Y")
      }
   end

   method processBreakpointResult(res)
   local body
      if \res["success"] == "__false__" then {
         response := build_response(request_seq, "__false__", request_command)
         writes(sock, response)
         return
      }

      bpSuccess +:= 1
      if res["type"] == "setBreakpoint" then {
         bp := [
            "id": res["breakpoint"]["id"];
            "line": res["breakpoint"]["line"];
            "verified": "__true__";
            "source": [
               "path": filePath||".icn"
            ]
         ]
         push(breakpointList, bp)
      }
      if bpSuccess == numBreakpoints then {
         body := table("breakpoints", breakpointList)
         response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], body)
         writes(sock, response)

         bpSuccess := 0
         breakpointList := []
      }
   end

   method processStackTraceResult(res)
   local response, frames := []
      if \res["success"] == "__false__" then {
         response := build_response(currentRequestBody["seq"], "__false__", currentRequestBody["command"])
         writes(sock, response)
         return
      }

      if member(res, "type") then {
         if res["type"] == "frame" then {
            res["name"] := replace(res["name"], "\"", "\\\"")
            res["consoleMsg"] := replace(res["consoleMsg"], "\"", "\\\"")
            put(frames, res)

            response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], table("stackFrames", frames))
            writes(sock, response)
         }
      }
   end

   method processScopesResult(res)
   local response
      if \res["success"] == "__false__" then {
         response := build_response(request_seq, "__false__", request_command)
         writes(sock, response)
         return
      }

      if member(res, "type") then {
         if member(res, "variables") then {
            numScopes +:= 1
            if res["type"] == "globals" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Globals", "variablesReference", 1))
            }
            if res["type"] == "locals" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Locals", "variablesReference", 2))
            }
            if res["type"] == "statics" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Statics", "variablesReference", 3))
            }
            if res["type"] == "params" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Parameters", "variablesReference", 4))
            }
         }
         else if res["type"] == "frame" then {
            if res["success"] == "__true__" then numScopes +:= 1
         }
      }
      if numScopes = 5 then {
         response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], table("scopes", scopesList))
         writes(sock, response)

         numScopes := 0
         scopesList := []
      }
      
   end

   method processVariablesResult(res)
   local response, variables, var
      if \res["success"] == "__false__" then {
         response := build_response(request_seq, "__false__", request_command)
         writes(sock, response)
         return
      }

      if member(res, "type") then {
         if member(res, "variables") then {
            if res["type"] == "globals" | "locals" | "statics" | "params" then {
               variables := res["variables"]

               every var := !variables do {
                  var["value"] := replace(var["value"], "\"", "\\\"")
                  var["type"] := replace(var["type"], "\"", "\\\"")
                  var["variablesReference"] := 0
               }

               response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], table("variables", variables))
               writes(sock, response)
            }
         }
      }
   end

   method processEvaluateResult(res)
   local event, body, response
      if res["type"] == "assignVar" then {
         if res["success"] == "__true__" then {
            body := [
               "result": res["value"];
               "variablesReference": 0
            ]
            response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], body)
            writes(sock, response)
         }
      }
      else if res["type"] == "setBreakpoint" then {
         if res["success"] == "__true__" then {
            body := [
               "reason": "new";
               "breakpoint": [
                  "id": res["breakpoint"]["id"];
                  "line": res["breakpoint"]["line"];
                  "verified": "__true__";
                  "source": [
                     "path": filePath||".icn"
                  ]
               ]
            ]
            event := build_event("breakpoint", body)
            writes(sock, event)
         }
      }
      else if res["type"] == "clearBreakpoint" then {
         if res["success"] == "__true__" then {
            body := [
               "reason": "removed";
               "breakpoint": [
                  "id": res["breakpoint"]["id"];
                  "line": res["breakpoint"]["line"];
                  "verified": "__true__";
                  "source": [
                     "path": filePath||".icn"
                  ]
               ]
            ]
            event := build_event("breakpoint", body)
            writes(sock, event)
         }
      }
   end

   # Handles all the things required from a client "evaluate" request.
   method evaluate(request_body, request_seq, request_command, request_arguments)
      local res, expression, result := "", isEvalExp

      expression := request_arguments["expression"]
      expression ? {
         if tab(match("-exec ")) then {
            expression := tab()
            lastUdbCmd := expression
         }
         else if expression ~== "" then {
            expression := "p "||expression
         }
         else if \lastUdbCmd then {
            expression := lastUdbCmd
         }
      }

      # Same thing here, maybe we put this as the head of cmdQueue.
      # Returning won't do anything.
      put_cmdQueue("frame "||request_arguments["frameId"], request_body)
      put_cmdQueue(expression, request_body)
   end

   # Handle a udb output table of "type" set to "crash".
   method handle_error(outputTable)
      local errorText, errorMessageTable, res, event
      udbError := "__true__"

      errorText := "Unicon Debugger experienced an error during " || currentRequestBody["command"] || " request. "
      if \outputTable then {
         errorText ||:= "Error number: " || outputTable["errornumber"] || ". "
         if member(outputTable, "errortext") then errorText ||:= "Error text: " || outputTable["errortext"] || ". "
         if member(outputTable, "errorvalue") then errorText ||:= "Error value: " || outputTable["errorvalue"] || ". "
      }
      errorText ||:= "Closing Unicon Debugger."

      errorMessageTable := ["format": errorText; "showUser": "__true__"]
      if \outputTable then errorMessageTable["id"] := outputTable["errornumber"]
      else errorMessageTable["id"] := 0

      res := build_response(currentRequestBody["seq"], "__false__", currentRequestBody["command"], ["error": errorMessageTable])
      writes(sock, res)

      event := build_event("terminated")
      writes(sock, event)
   end

   # Disconnect from client and udb and startup as a fresh session.
   method disconnect()
      # Kill terminal running dapcom
      kill(\shellProcessId, 9)
      # End communication with client
      close(\sock)
      # Restart session
      put_cmdQueue("reset")
   end

   # Open a port as a server and block until client connect.
   # Returns communication medium or fails.
   method open_sock(port)
        local sock
        if /port then return "port not declared"
        port := (if &features == "MacOS" then "127.0.0.1" else "") || ":" || port

        every !5 do
            if sock := open(port, "na") then
                return sock
            else
                delay(1000)

        write("udap failed to open port: " || port)
    end

   # Attempt to open communication port for client and set default class parameters.
   method startup()
      sock := open_sock(port)
      if /sock then stop("failed to connect to ",port)

      seq := 1
      udbError := &null
      lastUdbCmd := ""
      requestQueue := []
      cmdQueue := []
      numBreakpoints := 0
      breakpointList := []
      bpSuccess := 0
      scopesList := []
      numScopes := 0
   end

   initially
      startup()
end